import numpy as npimport pandas as pdfrom skimage.measure import regionprops_tabledef mito_properties(        mito_mask,        cell_mask,        cell_edge_distance,        cv_distance,        pv_distance,        save_path,        save=True):        mito_props_dict = regionprops_table(        mito_mask,        properties =(            'label',            'area',            'perimeter',            'centroid',            'axis_major_length',            'axis_minor_length',            'solidity')        )        mito_props = pd.DataFrame.from_dict(mito_props_dict)    mito_props['cell_id'] = map_to_cell(mito_props, cell_mask)    mito_props['aspect_ratio'] = mito_props['axis_major_length'] / \        mito_props['axis_minor_length']        # use formula to calc boundry to cell edge    mito_props['boundry_dist'] = map_to_cell(        mito_props, cell_edge_distance)                   # use new ascini distance measure    # portal vein = 1, central vein = -1    mito_props['ascini_position'] = ascini_position(        mito_props,        cv_distance,        pv_distance        )        mito_props['aspect_type_1'], \    mito_props['aspect_type_2'], \    mito_props['aspect_type_3'] = split_types(        mito_props,        'aspect_ratio',        (1.2, 2)        )    if save is True:        mito_props.to_csv(f'{save_path}mitochondria_properties.csv')        return mito_propsdef lipid_droplet_properties(        lipid_droplet_mask,        cell_mask,        cell_edge_distance,        cv_distance,        pv_distance,        save_path,        save=True        ):         ld_props_dict = regionprops_table(        lipid_droplet_mask,        properties =(            'label',            'area',            'perimeter',            'centroid',            'axis_major_length',            'axis_minor_length',            'solidity')        )        ld_props = pd.DataFrame.from_dict(ld_props_dict)    ld_props['cell_id'] = map_to_cell(ld_props, cell_mask)    ld_props['aspect_ratio'] = ld_props['axis_major_length'] / \        ld_props['axis_minor_length']            ld_props['boundry_dist'] = map_to_cell(        ld_props, cell_edge_distance)          ld_props['ascini_position'] = ascini_position(        ld_props,        cv_distance,        pv_distance        )        ld_props['area_type_1'], \    ld_props['area_type_2'], \    ld_props['area_type_3'] = split_types(        ld_props,        'area',        (500, 2000)        )        if save is True:        ld_props.to_csv(f'{save_path}lipid_dropplet_properties.csv')        return ld_propsdef map_to_cell(props, mask):    y_cords = np.asarray(props['centroid-0'], dtype='int')    x_cords = np.asarray(props['centroid-1'], dtype='int')        return mask[y_cords, x_cords]def split_types(organelle_list, prop, bounds):    '''    Split the given dataframe into types based on "prop" and cutoffs    '''        type_1 = organelle_list[prop] < bounds[0]    type_3 = organelle_list[prop] >= bounds[1]    type_2 = np.logical_or(type_1, type_3) == False        return type_1, type_2, type_3def ascini_position(props, cv_distance, pv_distance):    cv_distance = map_to_cell(props, cv_distance)    pv_distance = map_to_cell(props, pv_distance)    ascini_position = (pv_distance - cv_distance) / \        (pv_distance + cv_distance)        return ascini_position